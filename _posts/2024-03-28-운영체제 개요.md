---
title: 운영체제 개요
date: 2024-03-28 10:50:00 +09:00
categories: [
    Comcuter_Science,
]
tags: [
    CS,
    운영체제,
]
---

## 운영체제(Operating System)

 운영체제(Operating System, OS)는 컴퓨터 하드웨어와 사용자 간의 다리 역할을 하는 소프트웨어입니다. 운영체제는 컴퓨터의 모든 기본적인 작업을 관리하고, 다양한 응용 프로그램이 컴퓨터 하드웨어 자원을 효율적으로 사용할 수 있도록 지원합니다.


### 운영체제의 역할

 운영체제는 시스템 자원(프로세서, 메모리, 디스크 공간 등)을 관리하고, 사용자 및 다른 소프트웨어와 하드웨어 사이의 인터페이스 역할을 하는 시스템 소프트웨어의 집합입니다. 운영체제는 컴퓨터를 부팅할 때 메모리에 로드되며, 컴퓨터가 꺼질 때까지 시스템의 모든 활동을 관리하고 조정합니다.


### 운영체제의 목적

1. **자원 관리**: 운영체제는 CPU 시간, 메모리 공간, 파일 저장 공간, 입/출력 장치 등 컴퓨터 자원을 효율적으로 관리합니다. 여러 프로그램과 사용자 사이에서 자원을 공정하게 분배하고, 충돌 없이 자원을 사용할 수 있도록 합니다.

2. **사용자 인터페이스 제공**: 사용자가 컴퓨터와 상호작용할 수 있도록 인터페이스를 제공합니다. 이는 커맨드 라인 인터페이스(CLI) 또는 그래픽 사용자 인터페이스(GUI) 형태일 수 있습니다.

3. **프로그램 실행과 관리**: 운영체제는 프로그램을 메모리에 로드하고, 실행을 관리합니다. 프로세스 관리 기능을 통해 실행 중인 프로그램 간에 CPU 시간을 할당하고, 프로그램 실행의 순서를 조정합니다.

4. **데이터 관리와 파일 시스템**: 파일과 데이터의 저장, 검색, 업데이트를 관리합니다. 사용자와 응용 프로그램이 데이터를 쉽게 저장하고 접근할 수 있도록 파일 시스템을 통해 데이터를 조직화합니다.

5. **장치 관리**: 입/출력 장치를 관리하며, 장치 드라이버를 통해 하드웨어와 소프트웨어 간의 통신을 가능하게 합니다. 이를 통해 사용자와 응용 프로그램은 다양한 장치를 효율적으로 사용할 수 있습니다.

6. **보안 및 접근 제어**: 운영체제는 시스템의 보안을 유지하며, 무단 접근으로부터 시스템 자원을 보호합니다. 사용자 인증, 데이터 암호화, 접근 권한 관리 등을 통해 데이터의 안전성과 시스템의 안정성을 보장합니다.


## 운영체제?? 커널??
 커널은 운영체제의 핵심 부분으로, 운영체제의 핵심 기능을 수행하기 위해 필요한 구성요소입니다. 커널은 직접적으로 하드웨어와 상호작용하며, 시스템의 모든 핵심 관리 작업을 담당합니다. 


### 커널의 역할
 프로세스 관리, 메모리 관리, 파일 시스템의 관관리, 입/출력 제어, 장치 드라이버의 관리 등을 포함합니다. 커널은 사용자와 가장 가까운 하드웨어 계층과 소통하여, 운영체제의 다른 부분이 하드웨어 자원을 효율적으로 사용할 수 있도록 합니다.

- **프로세스 관리**: 실행 중인 모든 프로세스를 관리하며, CPU 시간을 어떻게 분배할지 결정합니다.
- **메모리 관리**: 시스템의 물리적 메모리를 관리하고, 프로세스가 필요로 하는 메모리를 할당 및 회수합니다.
- **장치 관리**: 컴퓨터에 연결된 모든 장치(키보드, 마우스, 디스크 드라이브 등)를 위한 드라이버와 인터페이스를 관리합니다.
- **입/출력 관리**: 데이터의 입/출력 흐름을 관리하고, 입/출력 장치와의 데이터 전송을 조정합니다.
- **파일 시스템 관리**: 파일과 데이터를 저장하고 접근하는 방법을 관리합니다.


### 쉘과의 차이
 쉘은 사용자와 커널 사이의 인터페이스를 제공하는 프로그램입니다. 사용자로부터 명령을 받아, 그것을 커널이 이해할 수 있는 형태로 변환하여 커널에 전달합니다. 쉘은 커맨드 라인 인터페이스(CLI) 또는 그래픽 사용자 인터페이스(GUI) 형태일 수 있습니다. 쉘은 사용자의 명령을 해석하고 실행하고, 커널은 시스템의 핵심적인 관리와 제어를 담당합니다.

#### 정리
 커널이 실제로 하드웨어와의 낮은 수준에서의 상호작용을 처리한다면, 쉘은 그보다 한 단계 추상화된 수준에서 사용자와 커널 사이의 소통을 담당합니다. 쉘은 사용자가 커널과 소통할 수 있도록 더 친숙하고 이해하기 쉬운 인터페이스를 제공합니다.

#### 커널과 하드웨어의 소통
 커널은 실제로 하드웨어와 상호작용할 때 저수준의 언어(어셈블리어나 기계어)를 사용합니다. 이는 프로세스 관리, 메모리 관리, 입출력 관리 등 커널의 핵심 기능을 효율적으로 수행하기 위해 필요합니다.

#### 쉘의 역할
 쉘은 사용자로부터 고수준의 명령어(예: 파일을 열거나, 프로그램을 실행하는 명령어)를 받아들이고, 이를 커널이 이해할 수 있는 형태로 변환하여 전달합니다. 사용자는 쉘을 통해 복잡한 커널 명령어나 프로그래밍 없이도 시스템과 상호작용할 수 있습니다.

#### 추상화??
 쉘은 복잡한 시스템 작업을 보다 단순하고 이해하기 쉬운 명령어로 추상화합니다. 이는 사용자가 컴퓨터 시스템을 보다 쉽게 제어할 수 있게 해 줍니다. 예를 들어, 사용자가 특정 파일을 삭제하고 싶을 때, 쉘을 통해 간단한 명령어를 입력하는 것만으로 해당 작업을 수행할 수 있습니다.

#### 정리
 커널이 실제로 하드웨어와의 낮은 수준에서의 상호작용을 처리한다면, 쉘은 그보다 한 단계 추상화된 수준에서 사용자와 커널 사이의 소통을 담당합니다. 쉘은 사용자가 커널과 소통할 수 있도록 더 친숙하고 이해하기 쉬운 인터페이스를 제공합니다.


### 중앙처리장치(CPU)의 구성
 중앙처리장치, 보다 흔하게 CPU라고 부르는 구성요소는 컴퓨터의 뇌와 같은 존재입니다. 해당 요소는 컴퓨터터가 사람이 시키는 작업을 할 수 있도록 명령을 실행하기 위해 제어와 연산, 그리고 기억의 주요 기능을 수행합니다.

- **산술논리연산장치(ALU)**: 숫자를 가지고 더하기, 빼기 같은 산술 연산과 AND, OR 같은 논리 연산을 담당합니다. 
- **제어장치(CU)**: ALU가 자기 역할을 할 수 있도록 일정을 관리하고, 무엇을 해야 할지 지시하는 부분입니다. 컴퓨터가 수행해야 할 명령어를 읽고, 해석하고, 실행하는 것을 총괄합니다.
- **레지스터**: CPU의 작은 기억 주머니라고 할 수 있습니다. 현재 진행 중인 작업에 필요한 데이터나 중간 결과물들을 임시로 저장해두는 곳으로 매우 빠른 속도를 가지고 있습니다.

### 시스템 버스
 CPU와 컴퓨터의 다른 부품들 사이에서 데이터를 운반하는 것을 시스템 버스라고 합니다. 시스템 버스는 마치 컴퓨터 도시의 대중교통 시스템 같이, 데이터, 주소, 제어 신호를 실어 나르며 CPU, 메모리, 입출력 장치들을 연결합니다.

- **데이터 버스**: 데이터를 실어 나르는 역할
- **주소 버스**: '데이터가 어디로 가야 할지'를 알려주는 버스 
- **제어 버스**: 제어 버스는 모든 것이 잘 진행되도록 지휘하는 
지휘자. 데이터의 전달, 수신 등 실행 관련 신호를 보냄

### 각 버스의 전송 방향성

1. **데이터 버스**: 양방향입니다. 데이터 버스는 CPU와 다른 컴퓨터 구성요소 사이에서 데이터를 전송합니다. CPU가 메모리나 입/출력 장치에 데이터를 쓰거나, 그 반대로 데이터를 읽을 때 사용됩니다.

2. **주소 버스**: 단방향입니다. 주소 버스는 CPU에서 메모리나 다른 입/출력 장치로 가는 주소 정보를 전송합니다. 이 주소 정보를 통해 CPU는 데이터를 저장하거나 읽어야 할 정확한 위치를 지정할 수 있습니다. 주소 버스가 단방향이라는 것은 주소 정보가 CPU에서 다른 구성요소로만 전송된다는 의미입니다.

3. **제어 버스**: 과거에는 단방향이었으나 최근에는 양방향입니다. 제어 버스는 CPU와 시스템의 다른 부분 사이에서 제어 신호를 전송합니다. 이 신호에는 데이터 읽기/쓰기 요청, 인터럽트 요청의 승인 및 거부, 그리고 시스템 클록 신호 등이 포함됩니다. 제어 버스를 통해 CPU는 시스템의 다른 부분을 제어하고, 반대로 다른 부분에서 CPU에 신호를 보낼 수도 있습니다.


## 프로그램 카운터

### 프로그램 카운터의 역할

- **명령어의 순서 유지**: 프로그램 카운터는 메모리 내에서 다음에 실행될 명령어의 주소를 저장합니다. CPU는 이 주소를 참조하여 다음 작업을 수행해야 할 명령어를 가져옵니다.
- **프로그램의 실행 제어**: 프로그램 실행 도중에 분기(branch)나 점프(jump) 같은 명령어를 만나면, 프로그램 카운터는 해당 명령어가 지정하는 새로운 주소로 업데이트됩니다. 이를 통해 프로그램의 흐름이 변경됩니다.
- **순차적 실행 보장**: 프로그램 카운터는 명령어가 메모리에 저장된 순서대로 실행되도록 보장합니다. 각 명령어 실행 후, 프로그램 카운터는 자동적으로 다음 명령어의 주소로 증가합니다.

### 프로그램 카운터의 작동 방식

1. **초기화**: 프로그램 실행이 시작될 때, 프로그램 카운터는 실행할 첫 번째 명령어의 주소로 설정됩니다.
2. **명령어 실행**: CPU는 프로그램 카운터가 가리키는 주소에 있는 명령어를 메모리로부터 가져와서 실행합니다.
3. **주소 업데이트**: 명령어 실행이 끝나면, 프로그램 카운터는 자동적으로 다음 명령어의 주소로 업데이트됩니다. 이 과정은 프로그램이 종료되거나, 특별한 분기/점프 명령어를 만나 변경되는 주소로 점프할 때까지 반복됩니다.

컴퓨터 시스템에서 프로세스 관리는 매우 중요한 부분입니다. 프로세스는 실행 중인 프로그램의 인스턴스로, 컴퓨터에서 수행되고 있는 작업을 나타냅니다. 이제 프로세스의 개념, 프로세스 상태 전이 과정, 그리고 프로세스 제어 블록(PCB)에 대해 자세히 알아보겠습니다.

## 프로세스

### 프로세스의 개념

 프로세스 == 실행 중인 프로그램
 프로세스는 실행을 위해 필요한 다양한 리소스(메모리, 파일 핸들, I/O 디바이스 등)와 함께 운영체제로부터 할당받은 자원을 포함하며, 각 프로세스는 고유한 주소 공간에서 실행됩니다. 그리고 최소한 하나 이상의 실행 스레드를 가집니다.

### 프로세스 상태 전이 과정

프로세스의 상태는 크게 다음과 같은 여러 단계로 나뉩니다:

1. **생성(New)**: 프로세스가 생성되고 초기화되는 상태입니다.
2. **준비(Ready)**: 프로세스가 CPU 할당을 기다리는 상태입니다. 모든 리소스를 준비하고 실행될 준비가 완료된 상태입니다.
3. **실행(Running)**: 프로세스가 CPU를 할당받아 명령어를 실행하는 상태입니다.
4. **대기(Waiting)**: 프로세스가 이벤트(예: I/O 작업의 완료)의 발생을 기다리는 상태입니다. 이 상태에서는 CPU를 할당받지 않습니다.
5. **종료(Terminated)**: 프로세스가 실행을 완료하고 시스템에서 제거되는 상태입니다.

프로세스는 이런 상태들 사이를 전이하면서 실행됩니다. 운영체제의 스케줄러는 이러한 프로세스들을 관리하며, 어떤 프로세스에 CP를 할당할지 결정합니다.

### 프로세스 제어 블록(Process Control Block, PCB)

PCB는 운영체제가 각 프로세스를 관리하기 위해 사용하는 데이터 구조입니다. PCB에는 프로세스의 중요한 정보가 저장되어 있으며, 다음과 같은 정보를 포함할 수 있습니다:

- **프로세스 식별자(Process ID)**: 프로세스를 고유하게 식별하는 번호입니다.
- **프로세스 상태**: 위에서 설명한 프로세스의 상태(준비, 실행, 대기 등) 정보입니다.
- **프로그램 카운터**: 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.
- **레지스터 세트**: 프로세스의 현재 레지스터 내용입니다.
- **메모리 관리 정보**: 프로세스의 메모리 할당 및 페이지 테이블 정보 등입니다.
- **계정 정보**: CPU 사용 시간, 제한 시간 등의 정보입니다.
- **I/O 상태 정보**: 프로세스에 할당된 I/O 장치와 열린 파일 목록 등입니다.

PCB는 프로세스가 CPU를 할당받아 실행되는 동안 필요한 모든 정보를 포함하고 있어, 프로세스의 실행 상태를 저장하고 복원하는 데 필수적입니다. 프로세스가 실행을 중단하고 나중에 다시 실행을 재개할 때, PCB를 통해 이전의 상태로 돌아갈 수 있습니다.

## 프로세스 스케줄링

 프로세스 스케줄링은 운영체제의 핵심 기능 중 하나로, CPU가 효율적으로 활용될 수 있도록 여러 프로세스 간에 CPU 사용 시간을 할당하는 방법을 말합니다. 

### CPU 스케줄링의 개념

 CPU 스케줄링은 시스템에 있는 여러 프로세스들에게 CPU를 할당하는 과정을 말합니다. 시스템의 효율성, 공정성, 응답 시간 등을 고려하여 최적의 프로세스 실행 순서를 결정합니다. CPU 스케줄러는 준비 상태에 있는 프로세스들 중에서 어떤 프로세스를 다음에 실행할지 결정하는 역할을 합니다.

### 스케줄링 평가 기준

 CPU 스케줄링의 효율성을 평가하는 기준은 다음과 같습니다.

- **CPU 사용률**: 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율입니다.
- **처리량(Throughput)**: 단위 시간당 처리할 수 있는 프로세스의 수(작업의 양)입니다.
- **응답 시간(Response Time)**: 사용자가 요청을 보낸 후 첫 번째 응답을 받기까지의 시간입니다.
- **대기 시간(Waiting Time)**: 프로세스가 준비 큐에서 실행될 차례를 기다리는 데 소비한 총 시간입니다.
- **반환 시간(Turnaround Time)**: 프로세스가 시작부터 종료까지 걸린 총 시간입니다.
- **공정성(Fairness)**: 모든 프로세스가 공정하게 CPU 시간을 할당받는지의 여부입니다.

### 프로세스 스케줄링의 분류

프로세스 스케줄링은 크게 선점(Preemptive) 스케줄링과 비선점(Non-preemptive) 스케줄링으로 나뉩니다.

- **비선점 스케줄링**: 한번 CPU를 할당받으면, 프로세스가 자발적으로 CPU를 방출하거나 실행이 완료될 때까지 CPU를 계속 사용합니다. FCFS(First-Come, First-Served)와 SJF(Shortest Job First), HRN(Hightest Response-ratio Next)가 이에 해당합니다.

- **선점 스케줄링**: 우선순위나 시간 할당량(타임퀀텀) 등의 조건에 따라 현재 실행 중인 프로세스를 중단시키고, 다른 프로세스에게 CPU를 할당할 수 있습니다. 이 방식은 시스템의 반응성을 높이고 더 유연한 프로세스 관리를 가능하게 합니다. 대표적인 예로는 RR(Round Robin), SRT(혹은 SRTF, Shortest Remaining Time First), MLQ(Multy Level Queue), MFQ(Multy Level Feedback Queue)가 이에 해당합니다.

프로세스 스케줄링의 목적은 시스템 자원을 효율적으로 사용하면서, 사용자에게 만족스러운 서비스를 제공하는 것입니다. 스케줄링 알고리즘은 시스템의 목표와 요구
사항에 따라 선택되며, 이는 시스템의 성능에 직접적인 영향을 미칩니다.

선점형 스케줄링과 비선점형 스케줄링은 프로세스에 CPU 사용 시간을 어떻게 할당하느냐에 따라 구분됩니다. 여기에는 다양한 스케줄링 알고리즘이 있으며, 각각의 알고리즘은 특정 상황에서 최적의 성능을 발휘하도록 설계되었습니다.


### 선점형 스케줄링(Preemptive Scheduling)

선점형 스케줄링은 한 프로세스가 CPU를 사용 중일 때, 스케줄러가 특정 조건에 따라 현재 프로세스의 실행을 중단시키고 다른 프로세스에게 CPU를 할당할 수 있는 방식입니다.

1. **라운드 로빈(Round Robin, RR)**: 각 프로세스는 동일한 크기의 시간 할당량(Time Slice, Time Quantum)을 받아 CPU를 사용합니다. 한 프로세스의 시간 할당량이 끝나면, 진행 중인 프로세스를 준비 큐로 되돌리고 다음 프로세스에게 CPU가 할당됩니다. 이를 통해 공평한 CPU 사용을 보장하며 실제 사용되는 운영체제들이 많이 사용하는 방식입니다.
2. **최소 잔여 시간 우선(Shortest Remaining Time First, SRTF)**: 비선점 스케줄링인 SJF 기법을 선점기법으로 변형한 형식입니다. 남은 실행 시간 추정치가 가장 적은(가장 짧은 실행 시간을 남겨둔) 프로세스에게 CPU를 우선 할당합니다. 새로운 프로세스가 도착하면 남은 실행 시간을 다시 계산하여, 현재 실행 중인 프로세스보다 짧은 실행 시간을 가진 프로세스가 있다면 CPU를 선점합니다. 그로 인해 기아현상이 발생가능하며, 남은 실행 시간의 추적으로 인해 오버헤드가 증가합니다.
3. **다단계 큐(Multilevel Queue, MLQ)**: 다단계 큐는 프로세스를 여러 개의 큐로 분류하여 관리하는 방식입니다. 각 큐는 특정 유형의 프로세스(예: 시스템 프로세스, 대화형 사용자 프로세스, 배치 작업 등)를 위해 할당되며, 각 큐에는 고유한 스케줄링 정책(예: FCFS, RR 등)이 적용됩니다. 다단계 큐는 프로세스 사이에 명확한 우선순위를 설정하여, 우선순위가 높은 큐의 프로세스가 먼저 CPU를 할당받도록 합니다. MLQ에서는 프로세스가 다른 큐로 이동하지 못합니다.
4. **다단계 피드백 큐(Multilevel Feedback Queue, MFQ)**: 다단계 피드백 큐는 다단계 큐의 확장된 형태로, 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비 큐를 사용하는 기법입니다. 각 프로세스는 CPU 할당시간을 가지며, 할당시간을 다 소모하면 낮은 준비 큐로 이동합니다. 이를 작업이 완료될 때까지 라운드 로빈으로 순환합니다. 이 방식은 프로세스의 우선순위를 동적으로 조정하여, 짧은 작업에 빠른 응답 시간을 제공하고, 긴 작업은 배경에서 실행되도록 합니다. 이를 통해 시스템의 공정성과 효율성을 높여 기아 상태를 예방합니다.

### 비선점형 스케줄링(Non-preemptive Scheduling)

비선점형 스케줄링은 프로세스가 CPU를 할당받으면, 그 프로세스가 자발적으로 CPU를 방출하거나 실행이 완료될 때까지 CPU를 계속 사용하는 방식입니다.

1. **선입선출(First-Come, First-Served, FCFS)**: 프로세스가 준비 큐에 도착한 순서대로 CPU를 할당받습니다. 가장 단순한 스케줄링 알고리즘 중 하나입니다.
2. **최단 작업 우선(Shortest Job First, SJF)**: 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당합니다. 이 방식은 평균 대기 시간이 가장 짧은 방식입니다. 그러나 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생 가능합니다. 그리고 준비 큐큐에 있는 프로세스의 작업시간 파악이 어렵습니다.
3. **우선순위 스케줄링(Priority Scheduling)**: 각 프로세스는 우선순위를 가지며, 높은 우선순위를 가진 프로세스가 먼저 CPU를 할당받습니다. 같은 우선순위의 프로세스 사이에서는 FCFS 방식을 적용할 수 있습니다.
4. **기한부(Deadline) 방식**: 기한부 스케줄링은 각 프로세스가 완료되어야 하는 명시적인 기한(Deadline)을 가지고 있으며, 스케줄러는 이 기한을 만족시키기 위해 프로세스를 스케줄링합니다. 이 방식은 주로 실시간 시스템에서 사용되며, 각 작업이 정해진 시간 내에 완료되도록 보장해야 하는 경우에 적합합니다. 기한을 충족시키지 못하는 작업은 시스템의 실패로 간주될 수 있습니다.
5. **최고 응답비 우선(Highest Response Ratio Next, HRN)**: HRN 스케줄링은 SJF를 보완한 기법으로, 대기 시간과 서비스 시간(실행 시간)을 고려하여 우선순위를 계산합니다. 각 프로세스의 우선순위는 응답비(Response Ratio, (대기 시간 + 서비스 시간) / 서비스 시간으로 계산)의 값이 높은 것부터 낮은 것 순으로 부여됩니다. HRN은 대기 시간이 긴 프로세스에 더 높은 우선순위를 부여하여, 공정성을 증가시키는 동시에, 짧은 작업에 대해서도 빠른 응답 시간을 제공합니다.

### 운영체제와 제어권의 관계

운영체제는 시스템 자원과 서비스의 관리자로, 프로세스에 대한 제어권을 가집니다. 운영체제는 프로세스 생성, 실행, 중단, 종료 등의 생명 주기를 관리하며, 이를 위해 스케줄링 알고리즘을 통해 프로세스에 CPU 사용 시간을 할당합니다. 제어권은 프로세스가 실행될 때 운영체제로부터 CPU로, 그리고 프로세스가 대기 상태로 들어갈 때 다시 운영체제로 전달됩니다. 이러한 제어권의 전달은 시스템의 효율적인 운영을 위해 필수적이며, 운영체제의 스케줄링 정책에 따라 결정됩니다.

