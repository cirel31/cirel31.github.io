---
title: 처음 정리하는 러스트 - 러스트에서 변수란?
date: 2024-05-01 20:11:57 +09:00
categories: [
    Programmin_Language,
    Rust,
]
tags: [
    rust,
    러스트,
]
---

### 정적 타입(Statically Typed) 언어

러스트는 정적 타입 언어입니다. 러스트의 모든 변수는 컴파일 시점에 타입이 결정되어야 합니다.
이 말은, 모든 변수, 표현식, 함수 등의 데이터 타입이 프로그램을 실행하기 전에 결정되고 검증되어야 함을 의미합니다.

```rust
fn main() {
    // `num`의 타입은 정수로 추론됩니다.
    let num = 5; 
    // `text`의 타입은 명시적으로 String입니다.
    let text: String = "Hello".to_string(); 

    // 타입 불일치 오류
    // 컴파일 오류: 타입 `i32`와 `String` 간에는 `+` 연산을 할 수 없기에 컴파일 시점에서 오류를 보여줍니다.
    let result = num + text; 
}

```


### 변수

변수는 데이터를 저장하기 위해 특정한 이름을 받은 메모리상의 공간입니다. 러스트에서 변수는 다음과 같은 특징을 가집니다.

1. **불변성(Immutability)**
    기본적으로, 러스트에서는 **변수에 값을 할당한 뒤에 그 값을 변경할 수 없습니다**.
    물론, **mut**과 같은 키워드를 사용하여 변수에 명시적으로 **가변성을 부여**할 수 있습니다.

2. **스코프(Scope)와 소유권(Onership)**
    러스트는 변수에 대한 독특한 **소유권**을 가지고 있습니다. 그러나 소유권에 대해 설명하기 전에 스코프에 대해 간단한 설명을 하겠습니다.
    러스트에는 **스코프**라는 개념이 있는데, 이는 **변수 또는 객체가 프로그램 내에서 유효하게 존재하는 범위를 정의**합니다.
    러스트의 스코프는 크게 두 가지, 블록 스코프와 함수 스코프가 있습니다.

    #### 블록 스코프(Block Scope)
    러스트에서 가장 **기본적인 스코프 단위는 블록**입니다. 러스트에서 **변수는 자신이 선언된 블록 내에서만 유효성을 가집니다**.
    러스트에서 블록은 중괄호({})로 구분하며, **변수는 자신이 선언된 블록이 끝날 때 메모리에서 값이 해제**됩니다.

    ```rust
    fn main() {
        // 'x'의 스코프 시작
        let x = 42; 

        {
            // 'y'의 스코프 시작
            let y = 55; 
            println!("내부 선언 변수: {}", y);
            println!("외부 선언 변수: {}", x);
        } // 'y'의 스코프 종료

        // 'y'의 스코프가 종료되어 메모리에서 해제되었기에, y를 호출하려 하면 오류가 발생합니다.
        println!("내부 선언 변수: {}", y);
        println!("외부 선언 변수: {}", x);
    }

    ```

    #### 함수 스코프(Function Scope)
    어떤 함수 내에서 선언된 변수는 그 함수 내에서만 접근 가능합니다. 러스트에서는 함수가 새롭게 호출될 때마다 해당 스코프 내의 변수들이 새로 생성되고 함수 실행이 종료될 때 해제됩니다.

    ```rust
    fn main() {
        // first_func 함수 실행 전에는 'number' 변수에 접근할 수 없습니다.
        first_func(); 
        // 'x'는 여기서 생성되며 main 함수 내에서만 유효합니다.
        let x = 100; 
        // 'x'의 값이 second_func의 매개변수로 복사됩니다.
        second_func(x);
    }

    fn first_func() {
        let number = 10; // 'number'의 스코프 시작
        println!("number: {}", number);
    }

    fn second_func(x: i32) {
        // 여기서의 'x'는 main에서 전달받은 'x'의 복사본입니다. 
        // main 함수의 'x'는 second_func 함수의 매개변수로 전달되었고
        // second_func 함수 스코프에서 새로운 'x' 변수에 값이 할당되었습니다.
        // 이 'x'는 second_func 내에서만 유효하며, main의 'x'와는 독립적입니다.
        println!("x: {}", x); 
    }

    ```    

    #### 소유권

    1. 변수를 선언하고 데이터를 할당하면, 그 변수는 할당된 데이터의 소유권을 갖습니다. 
    
    2. 한 시점에 값의 소유자는 오직 하나입니다. 어떤 시점에서든, 각 데이터 조각의 소유자는 오직 하나만 존재합니다.

    3. 변수가 그 스코프를 벗어나면, 그 변수가 소유한 데이터는 자동으로 메모리에서 해제되고 소유권도 사라집니다.
   

    ```rust
    fn main() {
        // s1은 "hello"의 소유권을 가집니다.
        let s1 = String::from("hello");
        // 소유권이 s1에서 s2로 이동합니다.
        let s2 = s1; 
        // s1의 소유권이 s2로 이동했기에 오류가 발생합니다.
        println!("{}, world!", s1); 
        // s2는 소유권을 가지고 있기에 출력이 가능합니다.
        println!("{}, world!", s2); 
    }
    ```